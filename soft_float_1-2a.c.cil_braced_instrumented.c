typedef enum {myFalse, myTrue} myBool; myBool __VERIFIER_nondet_myBool(void);
extern void __VERIFIER_reached_control(int, char const *);
extern void __VERIFIER_loop_head(int, char const *);
extern void __VERIFIER_control_true(int, char const *);
extern void __VERIFIER_control_false(int, char const *);
// This file is part of the SV-Benchmarks collection of verification tasks:
// https://gitlab.com/sosy-lab/benchmarking/sv-benchmarks
//
// SPDX-FileCopyrightText: 2012-2021 The SV-Benchmarks Community
// SPDX-FileCopyrightText: 2012 FBK-ES <https://es.fbk.eu/>
//
// SPDX-License-Identifier: Apache-2.0

extern void abort(void);
extern void __assert_fail(const char *, const char *, unsigned int, const char *) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
void reach_error() { __assert_fail("0", "soft_float_1-2a.c.cil.c", 3, "reach_error"); }
extern void abort(void);

extern char __VERIFIER_nondet_char(void);
extern unsigned int __VERIFIER_nondet_uint(void);
void __VERIFIER_assert(int cond) {
  { __VERIFIER_reached_control(17, " ");
if (!(cond)) { __VERIFIER_control_true(17, " ");

    ERROR: {reach_error();abort();}
  }}
  return;
}
/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

unsigned int base2flt(unsigned int m , int e ) 
{ unsigned int res ;
  unsigned int __retres4 ;

  {
  { __VERIFIER_reached_control(30, " ");
if (! m) { __VERIFIER_control_true(30, " ");

    __retres4 = 0U;
    goto return_label;
  } else { __VERIFIER_control_false(33, " ");


  }}
  { __VERIFIER_reached_control(36, " ");
if (m < 1U << 24U) { __VERIFIER_control_true(36, " ");

    {
    __VERIFIER_reached_control(38, " ");
 while (1) {printf("CBMC Instrumentation @ line38");static myBool pStored = myFalse;myBool flag=__VERIFIER_nondet_myBool();static unsigned int o__retres4;static int oe;static unsigned int om;static unsigned int ores;if(pStored){__CPROVER_assert(!(o__retres4==__retres4 && oe==e && om==m && ores==res),"recurrent state found");} if(flag){o__retres4=__retres4;oe=e;om=m;ores=res;pStored=myTrue;}  __VERIFIER_loop_head(38, " ");

      while_0_continue: /* CIL Label */ ;
      { __VERIFIER_reached_control(40, " ");
if (e <= -128) { __VERIFIER_control_true(40, " ");

        __retres4 = 0U;
        goto return_label;
      } else { __VERIFIER_control_false(43, " ");


      }}
      e = e - 1;
      m = m << 1U;
      { __VERIFIER_reached_control(48, " ");
if (m < 1U << 24U) { __VERIFIER_control_true(48, " ");


      } else { __VERIFIER_control_false(50, " ");

        goto while_0_break;
      }}
    }
    while_0_break: /* CIL Label */ ;
    }
  } else { __VERIFIER_control_false(56, " ");

    {
    __VERIFIER_reached_control(58, " ");
 while (1) {printf("CBMC Instrumentation @ line58");static myBool pStored = myFalse;myBool flag=__VERIFIER_nondet_myBool();static unsigned int o__retres4;static int oe;static unsigned int om;static unsigned int ores;if(pStored){__CPROVER_assert(!(o__retres4==__retres4 && oe==e && om==m && ores==res),"recurrent state found");} if(flag){o__retres4=__retres4;oe=e;om=m;ores=res;pStored=myTrue;}  __VERIFIER_loop_head(58, " ");

      while_1_continue: /* CIL Label */ ;
      { __VERIFIER_reached_control(60, " ");
if (m >= 1U << 25U) { __VERIFIER_control_true(60, " ");


      } else { __VERIFIER_control_false(62, " ");

        goto while_1_break;
      }}
      { __VERIFIER_reached_control(65, " ");
if (e >= 127) { __VERIFIER_control_true(65, " ");

        __retres4 = 4294967295U;
        goto return_label;
      } else { __VERIFIER_control_false(68, " ");


      }}
      e = e + 1;
      m = m >> 1U;
    }
    while_1_break: /* CIL Label */ ;
    }
  }}
  m = m & ~ (1U << 24U);
  res = m | ((unsigned int ) (e + 128) << 24U);
  __retres4 = res;
  return_label: /* CIL Label */ 
  return (__retres4);
}
}
unsigned int addflt(unsigned int a , unsigned int b ) 
{ unsigned int res ;
  unsigned int ma ;
  unsigned int mb ;
  unsigned int delta ;
  int ea ;
  int eb ;
  unsigned int tmp ;
  unsigned int __retres10 ;

  {
  { __VERIFIER_reached_control(95, " ");
if (a < b) { __VERIFIER_control_true(95, " ");

    tmp = a;
    a = b;
    b = tmp;
  } else { __VERIFIER_control_false(99, " ");


  }}
  { __VERIFIER_reached_control(102, " ");
if (! b) { __VERIFIER_control_true(102, " ");

    __retres10 = a;
    goto return_label;
  } else { __VERIFIER_control_false(105, " ");


  }}
  {
  ma = a & ((1U << 24U) - 1U);
  ea = (int )(a >> 24U) - 128;
  ma = ma | (1U << 24U);
  mb = b & ((1U << 24U) - 1U);
  eb = (int )(b >> 24U) - 128;
  mb = mb | (1U << 24U);
  __VERIFIER_assert(ea >= eb);
  delta = ea - eb;
  { __VERIFIER_reached_control(117, " ");
if(!(delta < sizeof(mb) * 8)) { __VERIFIER_control_true(117, " ");
abort();}}
  mb = mb >> delta;
  }
  { __VERIFIER_reached_control(120, " ");
if (! mb) { __VERIFIER_control_true(120, " ");

    __retres10 = a;
    goto return_label;
  } else { __VERIFIER_control_false(123, " ");


  }}
  ma = ma + mb;
  { __VERIFIER_reached_control(127, " ");
if (ma & (1U << 25U)) { __VERIFIER_control_true(127, " ");

    { __VERIFIER_reached_control(128, " ");
if (ea == 127) { __VERIFIER_control_true(128, " ");

      __retres10 = 4294967295U;
      goto return_label;
    } else { __VERIFIER_control_false(131, " ");


    }}
    ea = ea + 1;
    ma = ma >> 1U;
  } else { __VERIFIER_control_false(136, " ");


  }}
  {
  __VERIFIER_assert(ma < 1U << 25U);
  ma = ma & ((1U << 24U) - 1U);
  res = ma | ((unsigned int )(ea + 128) << 24U);
  }
  __retres10 = res;
  return_label: /* CIL Label */ 
  return (__retres10);
}
}
unsigned int mulflt(unsigned int a , unsigned int b ) 
{ unsigned int res ;
  unsigned int ma ;
  unsigned int mb ;
  unsigned long long accu ;
  int ea ;
  int eb ;
  unsigned int tmp ;
  unsigned int __retres10 ;

  {
  { __VERIFIER_reached_control(160, " ");
if (a < b) { __VERIFIER_control_true(160, " ");

    tmp = a;
    a = b;
    b = tmp;
  } else { __VERIFIER_control_false(164, " ");


  }}
  { __VERIFIER_reached_control(167, " ");
if (! b) { __VERIFIER_control_true(167, " ");

    __retres10 = 0U;
    goto return_label;
  } else { __VERIFIER_control_false(170, " ");


  }}
  ma = a & ((1U << 24U) - 1U);
  ea = (int )(a >> 24U) - 128;
  ma = ma | (1U << 24U);
  mb = b & ((1U << 24U) - 1U);
  eb = (int )(b >> 24U) - 128;
  mb = mb | (1U << 24U);
  ea = ea + eb;
  ea = ea + 24;
  { __VERIFIER_reached_control(181, " ");
if (ea > 127) { __VERIFIER_control_true(181, " ");

    __retres10 = 4294967295U;
    goto return_label;
  } else { __VERIFIER_control_false(184, " ");


  }}
  { __VERIFIER_reached_control(187, " ");
if (ea < -128) { __VERIFIER_control_true(187, " ");

    __retres10 = 0U;
    goto return_label;
  } else { __VERIFIER_control_false(190, " ");


  }}
  accu = ma;
  accu = accu * (unsigned long long )mb;
  accu = accu >> 24U;
  { __VERIFIER_reached_control(196, " ");
if (accu >= (unsigned long long )(1U << 25U)) { __VERIFIER_control_true(196, " ");

    { __VERIFIER_reached_control(197, " ");
if (ea == 127) { __VERIFIER_control_true(197, " ");

      __retres10 = 4294967295U;
      goto return_label;
    } else { __VERIFIER_control_false(200, " ");


    }}
    ea = ea + 1;
    accu = accu >> 1U;
    { __VERIFIER_reached_control(205, " ");
if (accu >= (unsigned long long )(1U << 25U)) { __VERIFIER_control_true(205, " ");

      __retres10 = 4294967295U;
      goto return_label;
    } else { __VERIFIER_control_false(208, " ");


    }}
  } else { __VERIFIER_control_false(211, " ");


  }}
  {
  __VERIFIER_assert(accu < (unsigned long long )(1U << 25U));
  __VERIFIER_assert(accu & (unsigned long long )(1U << 24U));
  ma = accu;
  ma = ma & ~ (1U << 24U);
  res = ma | (unsigned int )((ea + 128) << 24U);
  }
  __retres10 = res;
  return_label: /* CIL Label */ 
  return (__retres10);
}
}
int main(void) 
{ unsigned int a ;
  unsigned int ma  = __VERIFIER_nondet_uint();
  signed char ea  = __VERIFIER_nondet_char();
  unsigned int b ;
  unsigned int mb  = __VERIFIER_nondet_uint();
  signed char eb  = __VERIFIER_nondet_char();
  unsigned int r_add ;
  unsigned int zero ;
  int sa ;
  int sb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int __retres23 ;

  {
  {
  zero = base2flt(0, 0);
  a = base2flt(ma, ea);
  b = base2flt(mb, eb);
  }
  { __VERIFIER_reached_control(256, " ");
if (a < zero) { __VERIFIER_control_true(256, " ");

    sa = -1;
  } else { __VERIFIER_control_false(258, " ");

    { __VERIFIER_reached_control(259, " ");
if (a > zero) { __VERIFIER_control_true(259, " ");

      tmp = 1;
    } else { __VERIFIER_control_false(261, " ");

      tmp = 0;
    }}
    sa = tmp;
  }}
  { __VERIFIER_reached_control(266, " ");
if (b < zero) { __VERIFIER_control_true(266, " ");

    sb = -1;
  } else { __VERIFIER_control_false(268, " ");

    { __VERIFIER_reached_control(269, " ");
if (b > zero) { __VERIFIER_control_true(269, " ");

      tmp___0 = 1;
    } else { __VERIFIER_control_false(271, " ");

      tmp___0 = 0;
    }}
    sb = tmp___0;
  }}
  {
  r_add = addflt(a, b);
  }
  { __VERIFIER_reached_control(279, " ");
if (sa > 0) { __VERIFIER_control_true(279, " ");

    { __VERIFIER_reached_control(280, " ");
if (sb > 0) { __VERIFIER_control_true(280, " ");

      { __VERIFIER_reached_control(281, " ");
if (r_add < a) { __VERIFIER_control_true(281, " ");

        tmp___2 = -1;
      } else { __VERIFIER_control_false(283, " ");

        { __VERIFIER_reached_control(284, " ");
if (r_add > a) { __VERIFIER_control_true(284, " ");

          tmp___1 = 1;
        } else { __VERIFIER_control_false(286, " ");

          tmp___1 = 0;
        }}
        tmp___2 = tmp___1;
      }}
      {
      __VERIFIER_assert(tmp___2 >= 0);
      }
      { __VERIFIER_reached_control(294, " ");
if (r_add < b) { __VERIFIER_control_true(294, " ");

        tmp___4 = -1;
      } else { __VERIFIER_control_false(296, " ");

        { __VERIFIER_reached_control(297, " ");
if (r_add > b) { __VERIFIER_control_true(297, " ");

          tmp___3 = 1;
        } else { __VERIFIER_control_false(299, " ");

          tmp___3 = 0;
        }}
        tmp___4 = tmp___3;
      }}
      {
      __VERIFIER_assert(tmp___4 >= 0);
      }
    } else { __VERIFIER_control_false(307, " ");


    }}
  } else { __VERIFIER_control_false(310, " ");


  }}
  { __VERIFIER_reached_control(313, " ");
if (sa == 0) { __VERIFIER_control_true(313, " ");

    goto _L;
  } else { __VERIFIER_control_false(315, " ");

    { __VERIFIER_reached_control(316, " ");
if (sb == 0) { __VERIFIER_control_true(316, " ");

      _L: /* CIL Label */ 
      { __VERIFIER_reached_control(318, " ");
if (r_add < a) { __VERIFIER_control_true(318, " ");

        tmp___6 = -1;
      } else { __VERIFIER_control_false(320, " ");

        { __VERIFIER_reached_control(321, " ");
if (r_add > a) { __VERIFIER_control_true(321, " ");

          tmp___5 = 1;
        } else { __VERIFIER_control_false(323, " ");

          tmp___5 = 0;
        }}
        tmp___6 = tmp___5;
      }}
      { __VERIFIER_reached_control(328, " ");
if (tmp___6 == 0) { __VERIFIER_control_true(328, " ");

        tmp___9 = 1;
      } else { __VERIFIER_control_false(330, " ");

        { __VERIFIER_reached_control(331, " ");
if (r_add < b) { __VERIFIER_control_true(331, " ");

          tmp___8 = -1;
        } else { __VERIFIER_control_false(333, " ");

          { __VERIFIER_reached_control(334, " ");
if (r_add > b) { __VERIFIER_control_true(334, " ");

            tmp___7 = 1;
          } else { __VERIFIER_control_false(336, " ");

            tmp___7 = 0;
          }}
          tmp___8 = tmp___7;
        }}
        { __VERIFIER_reached_control(341, " ");
if (tmp___8 == 0) { __VERIFIER_control_true(341, " ");

          tmp___9 = 1;
        } else { __VERIFIER_control_false(343, " ");

          tmp___9 = 0;
        }}
      }}
      {
      __VERIFIER_assert(tmp___9);
      }
    } else { __VERIFIER_control_false(350, " ");


    }}
  }}
  __retres23 = 0;
  return (__retres23);
}
}
