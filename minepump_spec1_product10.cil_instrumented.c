typedef enum {myFalse, myTrue} myBool; myBool __VERIFIER_nondet_myBool(void);
extern void __VERIFIER_reached_control(int, char const *);
extern void __VERIFIER_loop_head(int, char const *);
extern void __VERIFIER_control_true(int, char const *);
extern void __VERIFIER_control_false(int, char const *);
// This file is part of the SV-Benchmarks collection of verification tasks:
// https://gitlab.com/sosy-lab/benchmarking/sv-benchmarks
//
// SPDX-FileCopyrightText: 2011-2013 Alexander von Rhein, University of Passau
// SPDX-FileCopyrightText: 2011-2021 The SV-Benchmarks Community
//
// SPDX-License-Identifier: Apache-2.0

extern void abort(void);
extern void __assert_fail(const char *, const char *, unsigned int, const char *) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));
void reach_error() { __assert_fail("0", "minepump_spec1_product10.cil.c", 3, "reach_error"); }

extern int __VERIFIER_nondet_int(void);
extern int printf (__const char *__restrict __format, ...);
/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct JoinPoint {
   void **(*fp)(struct JoinPoint * ) ;
   void **args ;
   int argsCount ;
   char const   **argsType ;
   void *(*arg)(int  , struct JoinPoint * ) ;
   char const   *(*argType)(int  , struct JoinPoint * ) ;
   void **retValue ;
   char const   *retType ;
   char const   *funcName ;
   char const   *targetName ;
   char const   *fileName ;
   char const   *kind ;
   void *excep_return ;
};
struct __UTAC__CFLOW_FUNC {
   int (*func)(int  , int  ) ;
   int val ;
   struct __UTAC__CFLOW_FUNC *next ;
};
struct __UTAC__EXCEPTION {
   void *jumpbuf ;
   unsigned long long prtValue ;
   int pops ;
   struct __UTAC__CFLOW_FUNC *cflowfuncs ;
};
typedef unsigned int size_t;
struct __ACC__ERR {
   void *v ;
   struct __ACC__ERR *next ;
};
#pragma merger(0,"wsllib_check.i","")
void __automaton_fail(void) 
{ 

  {
  ERROR: {reach_error();abort();}
  return;
}
}
#pragma merger(0,"Environment.i","")
void lowerWaterLevel(void) ;
void waterRise(void) ;
void changeMethaneLevel(void) ;
int isMethaneLevelCritical(void) ;
int getWaterLevel(void) ;
void printEnvironment(void) ;
int waterLevel  =    1;
int methaneLevelCritical  =    0;
void lowerWaterLevel(void) 
{ 

  {
  __VERIFIER_reached_control(71, __func__);
 if (waterLevel > 0) { __VERIFIER_control_true(71, __func__);

    waterLevel = waterLevel - 1;
  } else { __VERIFIER_control_false(73, __func__);


  }
  return;
}
}
void waterRise(void) 
{ 

  {
  __VERIFIER_reached_control(83, __func__);
 if (waterLevel < 2) { __VERIFIER_control_true(83, __func__);

    waterLevel = waterLevel + 1;
  } else { __VERIFIER_control_false(85, __func__);


  }
  return;
}
}
void changeMethaneLevel(void) 
{ 

  {
  __VERIFIER_reached_control(95, __func__);
 if (methaneLevelCritical) { __VERIFIER_control_true(95, __func__);

    methaneLevelCritical = 0;
  } else { __VERIFIER_control_false(97, __func__);

    methaneLevelCritical = 1;
  }
  return;
}
}
int isMethaneLevelCritical(void) 
{ int retValue_acc ;

  {
  retValue_acc = methaneLevelCritical;
  return (retValue_acc);
  return (retValue_acc);
}
}
void printEnvironment(void) 
{ 

  {
  {
  printf("Env(Water:%i", waterLevel);
  printf(",Meth:");
  }
  __VERIFIER_reached_control(120, __func__);
 if (methaneLevelCritical) { __VERIFIER_control_true(120, __func__);

    {
    printf("CRIT");
    }
  } else { __VERIFIER_control_false(124, __func__);

    {
    printf("OK");
    }
  }
  {
  printf(")");
  }
  return;
}
}
int getWaterLevel(void) 
{ int retValue_acc ;

  {
  retValue_acc = waterLevel;
  return (retValue_acc);
  return (retValue_acc);
}
}
#pragma merger(0,"scenario.i","")
void startSystem(void) ;
void timeShift(void) ;
void cleanup(void) ;
void test(void) 
{ int splverifierCounter ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  splverifierCounter = 0;
  {
 myBool pStored0 = myFalse; __VERIFIER_reached_control(158, __func__);
 while (1) { __VERIFIER_loop_head(158, __func__);
printf("CBMC Instrumentation @ line158");myBool flag=__VERIFIER_nondet_myBool();static int omethaneLevelCritical;static int osplverifierCounter;static int otmp;static int otmp___0;static int otmp___1;static int otmp___2;static int owaterLevel;if(pStored0){__CPROVER_assert(!(omethaneLevelCritical==methaneLevelCritical && osplverifierCounter==splverifierCounter && otmp==tmp && otmp___0==tmp___0 && otmp___1==tmp___1 && otmp___2==tmp___2 && owaterLevel==waterLevel),"recurrent state found");} if(flag){omethaneLevelCritical=methaneLevelCritical;osplverifierCounter=splverifierCounter;otmp=tmp;otmp___0=tmp___0;otmp___1=tmp___1;otmp___2=tmp___2;owaterLevel=waterLevel;pStored0=myTrue;} 
    while_0_continue: /* CIL Label */ ;
    __VERIFIER_reached_control(160, __func__);
 if (splverifierCounter < 4) { __VERIFIER_control_true(160, __func__);


    } else { __VERIFIER_control_false(162, __func__);

      goto while_0_break;
    }
    {
    tmp = __VERIFIER_nondet_int();
    }
    __VERIFIER_reached_control(168, __func__);
 if (tmp) { __VERIFIER_control_true(168, __func__);

      {
      waterRise();
      }
    } else { __VERIFIER_control_false(172, __func__);


    }
    {
    tmp___0 = __VERIFIER_nondet_int();
    }
    __VERIFIER_reached_control(178, __func__);
 if (tmp___0) { __VERIFIER_control_true(178, __func__);

      {
      changeMethaneLevel();
      }
    } else { __VERIFIER_control_false(182, __func__);


    }
    {
    tmp___2 = __VERIFIER_nondet_int();
    }
    __VERIFIER_reached_control(188, __func__);
 if (tmp___2) { __VERIFIER_control_true(188, __func__);

      {
      startSystem();
      }
    } else { __VERIFIER_control_false(192, __func__);

      {
      tmp___1 = __VERIFIER_nondet_int();
      }
      __VERIFIER_reached_control(196, __func__);
 if (tmp___1) { __VERIFIER_control_true(196, __func__);


      } else { __VERIFIER_control_false(198, __func__);


      }
    }
    {
    timeShift();
    }
  }
  while_0_break: /* CIL Label */ ;
  }
  {
  cleanup();
  }
  return;
}
}
#pragma merger(0,"Test.i","")
int cleanupTimeShifts  =    4;
void cleanup(void) 
{ int i ;
  int __cil_tmp2 ;

  {
  {
  timeShift();
  i = 0;
  }
  {
 myBool pStored1 = myFalse; __VERIFIER_reached_control(226, __func__);
 while (1) { __VERIFIER_loop_head(226, __func__);
printf("CBMC Instrumentation @ line226");myBool flag=__VERIFIER_nondet_myBool();static int o__cil_tmp2;static int ocleanupTimeShifts;static int oi;static int omethaneLevelCritical;static int owaterLevel;if(pStored1){__CPROVER_assert(!(o__cil_tmp2==__cil_tmp2 && ocleanupTimeShifts==cleanupTimeShifts && oi==i && omethaneLevelCritical==methaneLevelCritical && owaterLevel==waterLevel),"recurrent state found");} if(flag){o__cil_tmp2=__cil_tmp2;ocleanupTimeShifts=cleanupTimeShifts;oi=i;omethaneLevelCritical=methaneLevelCritical;owaterLevel=waterLevel;pStored1=myTrue;} 
    while_1_continue: /* CIL Label */ ;
    {
    __cil_tmp2 = cleanupTimeShifts - 1;
    __VERIFIER_reached_control(230, __func__);
 if (i < __cil_tmp2) { __VERIFIER_control_true(230, __func__);


    } else { __VERIFIER_control_false(232, __func__);

      goto while_1_break;
    }
    }
    {
    timeShift();
    i = i + 1;
    }
  }
  while_1_break: /* CIL Label */ ;
  }
  return;
}
}
void printPump(void) ;
void Specification2(void) 
{ 

  {
  {
  timeShift();
  printPump();
  timeShift();
  printPump();
  timeShift();
  printPump();
  waterRise();
  printPump();
  timeShift();
  printPump();
  changeMethaneLevel();
  printPump();
  timeShift();
  printPump();
  cleanup();
  }
  return;
}
}
void setup(void) 
{ 

  {
  return;
}
}
void runTest(void) 
{ 

  {
  {
  test();
  }
  return;
}
}
void select_helpers(void) ;
void select_features(void) ;
int valid_product(void) ;
int main(void) 
{ int retValue_acc ;
  int tmp ;

  {
  {
  select_helpers();
  select_features();
  tmp = valid_product();
  }
  __VERIFIER_reached_control(301, __func__);
 if (tmp) { __VERIFIER_control_true(301, __func__);

    {
    setup();
    runTest();
    }
  } else { __VERIFIER_control_false(306, __func__);


  }
  retValue_acc = 0;
  return (retValue_acc);
  return (retValue_acc);
}
}
#pragma merger(0,"libacc.i","")
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
void __utac__exception__cf_handler_set(void *exception , int (*cflow_func)(int  ,
                                                                           int  ) ,
                                       int val ) 
{ struct __UTAC__EXCEPTION *excep ;
  struct __UTAC__CFLOW_FUNC *cf ;
  void *tmp ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int (**mem_15)(int  , int  ) ;
  int *mem_16 ;
  struct __UTAC__CFLOW_FUNC **mem_17 ;
  struct __UTAC__CFLOW_FUNC **mem_18 ;
  struct __UTAC__CFLOW_FUNC **mem_19 ;

  {
  {
  excep = (struct __UTAC__EXCEPTION *)exception;
  tmp = malloc(24UL);
  cf = (struct __UTAC__CFLOW_FUNC *)tmp;
  mem_15 = (int (**)(int  , int  ))cf;
  *mem_15 = cflow_func;
  __cil_tmp7 = (unsigned long )cf;
  __cil_tmp8 = __cil_tmp7 + 8;
  mem_16 = (int *)__cil_tmp8;
  *mem_16 = val;
  __cil_tmp9 = (unsigned long )cf;
  __cil_tmp10 = __cil_tmp9 + 16;
  __cil_tmp11 = (unsigned long )excep;
  __cil_tmp12 = __cil_tmp11 + 24;
  mem_17 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp10;
  mem_18 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp12;
  *mem_17 = *mem_18;
  __cil_tmp13 = (unsigned long )excep;
  __cil_tmp14 = __cil_tmp13 + 24;
  mem_19 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp14;
  *mem_19 = cf;
  }
  return;
}
}
void __utac__exception__cf_handler_free(void *exception ) 
{ struct __UTAC__EXCEPTION *excep ;
  struct __UTAC__CFLOW_FUNC *cf ;
  struct __UTAC__CFLOW_FUNC *tmp ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct __UTAC__CFLOW_FUNC *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  struct __UTAC__CFLOW_FUNC **mem_15 ;
  struct __UTAC__CFLOW_FUNC **mem_16 ;
  struct __UTAC__CFLOW_FUNC **mem_17 ;

  {
  excep = (struct __UTAC__EXCEPTION *)exception;
  __cil_tmp5 = (unsigned long )excep;
  __cil_tmp6 = __cil_tmp5 + 24;
  mem_15 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp6;
  cf = *mem_15;
  {
 myBool pStored2 = myFalse; __VERIFIER_reached_control(392, __func__);
 while (1) { __VERIFIER_loop_head(392, __func__);
printf("CBMC Instrumentation @ line392");myBool flag=__VERIFIER_nondet_myBool();static unsigned long o__cil_tmp10;static unsigned long o__cil_tmp11;static unsigned long o__cil_tmp12;static unsigned long o__cil_tmp13;static unsigned long o__cil_tmp14;static unsigned long o__cil_tmp5;static unsigned long o__cil_tmp6;static unsigned long o__cil_tmp7;static unsigned long o__cil_tmp8;static unsigned long o__cil_tmp9;static int ocleanupTimeShifts;static int omethaneLevelCritical;static int otmp;static int owaterLevel;if(pStored2){__CPROVER_assert(!(o__cil_tmp10==__cil_tmp10 && o__cil_tmp11==__cil_tmp11 && o__cil_tmp12==__cil_tmp12 && o__cil_tmp13==__cil_tmp13 && o__cil_tmp14==__cil_tmp14 && o__cil_tmp5==__cil_tmp5 && o__cil_tmp6==__cil_tmp6 && o__cil_tmp7==__cil_tmp7 && o__cil_tmp8==__cil_tmp8 && o__cil_tmp9==__cil_tmp9 && ocleanupTimeShifts==cleanupTimeShifts && omethaneLevelCritical==methaneLevelCritical && otmp==tmp && owaterLevel==waterLevel),"recurrent state found");} if(flag){o__cil_tmp10=__cil_tmp10;o__cil_tmp11=__cil_tmp11;o__cil_tmp12=__cil_tmp12;o__cil_tmp13=__cil_tmp13;o__cil_tmp14=__cil_tmp14;o__cil_tmp5=__cil_tmp5;o__cil_tmp6=__cil_tmp6;o__cil_tmp7=__cil_tmp7;o__cil_tmp8=__cil_tmp8;o__cil_tmp9=__cil_tmp9;ocleanupTimeShifts=cleanupTimeShifts;omethaneLevelCritical=methaneLevelCritical;otmp=tmp;owaterLevel=waterLevel;pStored2=myTrue;} 
    while_2_continue: /* CIL Label */ ;
    {
    __cil_tmp7 = (struct __UTAC__CFLOW_FUNC *)0;
    __cil_tmp8 = (unsigned long )__cil_tmp7;
    __cil_tmp9 = (unsigned long )cf;
    __VERIFIER_reached_control(398, __func__);
 if (__cil_tmp9 != __cil_tmp8) { __VERIFIER_control_true(398, __func__);


    } else { __VERIFIER_control_false(400, __func__);

      goto while_2_break;
    }
    }
    {
    tmp = cf;
    __cil_tmp10 = (unsigned long )cf;
    __cil_tmp11 = __cil_tmp10 + 16;
    mem_16 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp11;
    cf = *mem_16;
    __cil_tmp12 = (void *)tmp;
    free(__cil_tmp12);
    }
  }
  while_2_break: /* CIL Label */ ;
  }
  __cil_tmp13 = (unsigned long )excep;
  __cil_tmp14 = __cil_tmp13 + 24;
  mem_17 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp14;
  *mem_17 = (struct __UTAC__CFLOW_FUNC *)0;
  return;
}
}
void __utac__exception__cf_handler_reset(void *exception ) 
{ struct __UTAC__EXCEPTION *excep ;
  struct __UTAC__CFLOW_FUNC *cf ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  struct __UTAC__CFLOW_FUNC *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int (*__cil_tmp10)(int  , int  ) ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  struct __UTAC__CFLOW_FUNC **mem_16 ;
  int (**mem_17)(int  , int  ) ;
  int *mem_18 ;
  struct __UTAC__CFLOW_FUNC **mem_19 ;

  {
  excep = (struct __UTAC__EXCEPTION *)exception;
  __cil_tmp5 = (unsigned long )excep;
  __cil_tmp6 = __cil_tmp5 + 24;
  mem_16 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp6;
  cf = *mem_16;
  {
 myBool pStored3 = myFalse; __VERIFIER_reached_control(449, __func__);
 while (1) { __VERIFIER_loop_head(449, __func__);
printf("CBMC Instrumentation @ line449");myBool flag=__VERIFIER_nondet_myBool();static unsigned long o__cil_tmp10;static unsigned long o__cil_tmp11;static unsigned long o__cil_tmp12;static unsigned long o__cil_tmp13;static unsigned long o__cil_tmp14;static unsigned long o__cil_tmp15;static unsigned long o__cil_tmp5;static unsigned long o__cil_tmp6;static unsigned long o__cil_tmp7;static unsigned long o__cil_tmp8;static unsigned long o__cil_tmp9;static int ocleanupTimeShifts;static int omethaneLevelCritical;static int owaterLevel;if(pStored3){__CPROVER_assert(!(o__cil_tmp10==__cil_tmp10 && o__cil_tmp11==__cil_tmp11 && o__cil_tmp12==__cil_tmp12 && o__cil_tmp13==__cil_tmp13 && o__cil_tmp14==__cil_tmp14 && o__cil_tmp15==__cil_tmp15 && o__cil_tmp5==__cil_tmp5 && o__cil_tmp6==__cil_tmp6 && o__cil_tmp7==__cil_tmp7 && o__cil_tmp8==__cil_tmp8 && o__cil_tmp9==__cil_tmp9 && ocleanupTimeShifts==cleanupTimeShifts && omethaneLevelCritical==methaneLevelCritical && owaterLevel==waterLevel),"recurrent state found");} if(flag){o__cil_tmp10=__cil_tmp10;o__cil_tmp11=__cil_tmp11;o__cil_tmp12=__cil_tmp12;o__cil_tmp13=__cil_tmp13;o__cil_tmp14=__cil_tmp14;o__cil_tmp15=__cil_tmp15;o__cil_tmp5=__cil_tmp5;o__cil_tmp6=__cil_tmp6;o__cil_tmp7=__cil_tmp7;o__cil_tmp8=__cil_tmp8;o__cil_tmp9=__cil_tmp9;ocleanupTimeShifts=cleanupTimeShifts;omethaneLevelCritical=methaneLevelCritical;owaterLevel=waterLevel;pStored3=myTrue;} 
    while_3_continue: /* CIL Label */ ;
    {
    __cil_tmp7 = (struct __UTAC__CFLOW_FUNC *)0;
    __cil_tmp8 = (unsigned long )__cil_tmp7;
    __cil_tmp9 = (unsigned long )cf;
    __VERIFIER_reached_control(455, __func__);
 if (__cil_tmp9 != __cil_tmp8) { __VERIFIER_control_true(455, __func__);


    } else { __VERIFIER_control_false(457, __func__);

      goto while_3_break;
    }
    }
    {
    mem_17 = (int (**)(int  , int  ))cf;
    __cil_tmp10 = *mem_17;
    __cil_tmp11 = (unsigned long )cf;
    __cil_tmp12 = __cil_tmp11 + 8;
    mem_18 = (int *)__cil_tmp12;
    __cil_tmp13 = *mem_18;
    (*__cil_tmp10)(4, __cil_tmp13);
    __cil_tmp14 = (unsigned long )cf;
    __cil_tmp15 = __cil_tmp14 + 16;
    mem_19 = (struct __UTAC__CFLOW_FUNC **)__cil_tmp15;
    cf = *mem_19;
    }
  }
  while_3_break: /* CIL Label */ ;
  }
  {
  __utac__exception__cf_handler_free(exception);
  }
  return;
}
}
void *__utac__error_stack_mgt(void *env , int mode , int count ) ;
static struct __ACC__ERR *head  =    (struct __ACC__ERR *)0;
void *__utac__error_stack_mgt(void *env , int mode , int count ) 
{ void *retValue_acc ;
  struct __ACC__ERR *new ;
  void *tmp ;
  struct __ACC__ERR *temp ;
  struct __ACC__ERR *next ;
  void *excep ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  void *__cil_tmp17 ;
  void **mem_18 ;
  struct __ACC__ERR **mem_19 ;
  struct __ACC__ERR **mem_20 ;
  void **mem_21 ;
  struct __ACC__ERR **mem_22 ;
  void **mem_23 ;
  void **mem_24 ;

  {
  __VERIFIER_reached_control(509, __func__);
 if (count == 0) { __VERIFIER_control_true(509, __func__);

    return (retValue_acc);
  } else { __VERIFIER_control_false(511, __func__);


  }
  __VERIFIER_reached_control(514, __func__);
 if (mode == 0) { __VERIFIER_control_true(514, __func__);

    {
    tmp = malloc(16UL);
    new = (struct __ACC__ERR *)tmp;
    mem_18 = (void **)new;
    *mem_18 = env;
    __cil_tmp10 = (unsigned long )new;
    __cil_tmp11 = __cil_tmp10 + 8;
    mem_19 = (struct __ACC__ERR **)__cil_tmp11;
    *mem_19 = head;
    head = new;
    retValue_acc = (void *)new;
    }
    return (retValue_acc);
  } else { __VERIFIER_control_false(528, __func__);


  }
  __VERIFIER_reached_control(531, __func__);
 if (mode == 1) { __VERIFIER_control_true(531, __func__);

    temp = head;
    {
   myBool pStored4 = myFalse; __VERIFIER_reached_control(534, __func__);
 while (1) { __VERIFIER_loop_head(534, __func__);
printf("CBMC Instrumentation @ line534");myBool flag=__VERIFIER_nondet_myBool();static unsigned long o__cil_tmp10;static unsigned long o__cil_tmp11;static unsigned long o__cil_tmp12;static unsigned long o__cil_tmp13;static unsigned long o__cil_tmp14;static unsigned long o__cil_tmp15;static unsigned long o__cil_tmp16;static int ocleanupTimeShifts;static int ocount;static int omethaneLevelCritical;static int omode;static int oretValue_acc;static int otmp;static int owaterLevel;if(pStored4){__CPROVER_assert(!(o__cil_tmp10==__cil_tmp10 && o__cil_tmp11==__cil_tmp11 && o__cil_tmp12==__cil_tmp12 && o__cil_tmp13==__cil_tmp13 && o__cil_tmp14==__cil_tmp14 && o__cil_tmp15==__cil_tmp15 && o__cil_tmp16==__cil_tmp16 && ocleanupTimeShifts==cleanupTimeShifts && ocount==count && omethaneLevelCritical==methaneLevelCritical && omode==mode && oretValue_acc==retValue_acc && otmp==tmp && owaterLevel==waterLevel),"recurrent state found");} if(flag){o__cil_tmp10=__cil_tmp10;o__cil_tmp11=__cil_tmp11;o__cil_tmp12=__cil_tmp12;o__cil_tmp13=__cil_tmp13;o__cil_tmp14=__cil_tmp14;o__cil_tmp15=__cil_tmp15;o__cil_tmp16=__cil_tmp16;ocleanupTimeShifts=cleanupTimeShifts;ocount=count;omethaneLevelCritical=methaneLevelCritical;omode=mode;oretValue_acc=retValue_acc;otmp=tmp;owaterLevel=waterLevel;pStored4=myTrue;} 
      while_4_continue: /* CIL Label */ ;
      __VERIFIER_reached_control(536, __func__);
 if (count > 1) { __VERIFIER_control_true(536, __func__);


      } else { __VERIFIER_control_false(538, __func__);

        goto while_4_break;
      }
      {
      __cil_tmp12 = (unsigned long )temp;
      __cil_tmp13 = __cil_tmp12 + 8;
      mem_20 = (struct __ACC__ERR **)__cil_tmp13;
      next = *mem_20;
      mem_21 = (void **)temp;
      excep = *mem_21;
      __cil_tmp14 = (void *)temp;
      free(__cil_tmp14);
      __utac__exception__cf_handler_reset(excep);
      temp = next;
      count = count - 1;
      }
    }
    while_4_break: /* CIL Label */ ;
    }
    {
    __cil_tmp15 = (unsigned long )temp;
    __cil_tmp16 = __cil_tmp15 + 8;
    mem_22 = (struct __ACC__ERR **)__cil_tmp16;
    head = *mem_22;
    mem_23 = (void **)temp;
    excep = *mem_23;
    __cil_tmp17 = (void *)temp;
    free(__cil_tmp17);
    __utac__exception__cf_handler_reset(excep);
    retValue_acc = excep;
    }
    return (retValue_acc);
  } else { __VERIFIER_control_false(570, __func__);


  }
  __VERIFIER_reached_control(573, __func__);
 if (mode == 2) { __VERIFIER_control_true(573, __func__);

    __VERIFIER_reached_control(574, __func__);
 if (head) { __VERIFIER_control_true(574, __func__);

      mem_24 = (void **)head;
      retValue_acc = *mem_24;
      return (retValue_acc);
    } else { __VERIFIER_control_false(578, __func__);

      retValue_acc = (void *)0;
      return (retValue_acc);
    }
  } else { __VERIFIER_control_false(582, __func__);


  }
  return (retValue_acc);
}
}
void *__utac__get_this_arg(int i , struct JoinPoint *this ) 
{ void *retValue_acc ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void **__cil_tmp10 ;
  void **__cil_tmp11 ;
  int *mem_12 ;
  void ***mem_13 ;

  {
  __VERIFIER_reached_control(602, __func__);
 if (i > 0) { __VERIFIER_control_true(602, __func__);

    {
    __cil_tmp4 = (unsigned long )this;
    __cil_tmp5 = __cil_tmp4 + 16;
    mem_12 = (int *)__cil_tmp5;
    __cil_tmp6 = *mem_12;
    __VERIFIER_reached_control(608, __func__);
 if (i <= __cil_tmp6) { __VERIFIER_control_true(608, __func__);


    } else { __VERIFIER_control_false(610, __func__);

      {
      __assert_fail("i > 0 && i <= this->argsCount", "libacc.c",
                    123U, "__utac__get_this_arg");
      }
    }
    }
  } else { __VERIFIER_control_false(617, __func__);

    {
    __assert_fail("i > 0 && i <= this->argsCount", "libacc.c",
                  123U, "__utac__get_this_arg");
    }
  }
  __cil_tmp7 = i - 1;
  __cil_tmp8 = (unsigned long )this;
  __cil_tmp9 = __cil_tmp8 + 8;
  mem_13 = (void ***)__cil_tmp9;
  __cil_tmp10 = *mem_13;
  __cil_tmp11 = __cil_tmp10 + __cil_tmp7;
  retValue_acc = *__cil_tmp11;
  return (retValue_acc);
  return (retValue_acc);
}
}
char const   *__utac__get_this_argtype(int i , struct JoinPoint *this ) 
{ char const   *retValue_acc ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char const   **__cil_tmp10 ;
  char const   **__cil_tmp11 ;
  int *mem_12 ;
  char const   ***mem_13 ;

  {
  __VERIFIER_reached_control(648, __func__);
 if (i > 0) { __VERIFIER_control_true(648, __func__);

    {
    __cil_tmp4 = (unsigned long )this;
    __cil_tmp5 = __cil_tmp4 + 16;
    mem_12 = (int *)__cil_tmp5;
    __cil_tmp6 = *mem_12;
    __VERIFIER_reached_control(654, __func__);
 if (i <= __cil_tmp6) { __VERIFIER_control_true(654, __func__);


    } else { __VERIFIER_control_false(656, __func__);

      {
      __assert_fail("i > 0 && i <= this->argsCount", "libacc.c",
                    131U, "__utac__get_this_argtype");
      }
    }
    }
  } else { __VERIFIER_control_false(663, __func__);

    {
    __assert_fail("i > 0 && i <= this->argsCount", "libacc.c",
                  131U, "__utac__get_this_argtype");
    }
  }
  __cil_tmp7 = i - 1;
  __cil_tmp8 = (unsigned long )this;
  __cil_tmp9 = __cil_tmp8 + 24;
  mem_13 = (char const   ***)__cil_tmp9;
  __cil_tmp10 = *mem_13;
  __cil_tmp11 = __cil_tmp10 + __cil_tmp7;
  retValue_acc = *__cil_tmp11;
  return (retValue_acc);
  return (retValue_acc);
}
}
#pragma merger(0,"MinePump.i","")
void activatePump(void) ;
void deactivatePump(void) ;
int isPumpRunning(void) ;
int pumpRunning  =    0;
int systemActive  =    1;
void __utac_acc__Specification1_spec__1(void) ;
void processEnvironment(void) ;
void timeShift(void) 
{ 

  {
  __VERIFIER_reached_control(692, __func__);
 if (pumpRunning) { __VERIFIER_control_true(692, __func__);

    {
    lowerWaterLevel();
    }
  } else { __VERIFIER_control_false(696, __func__);


  }
  __VERIFIER_reached_control(699, __func__);
 if (systemActive) { __VERIFIER_control_true(699, __func__);

    {
    processEnvironment();
    }
  } else { __VERIFIER_control_false(703, __func__);


  }
  {
  __utac_acc__Specification1_spec__1();
  }
  return;
}
}
void processEnvironment(void) 
{ 

  {
  return;
}
}
void activatePump__wrappee__base(void) 
{ 

  {
  pumpRunning = 1;
  return;
}
}
int isMethaneAlarm(void) ;
void activatePump(void) 
{ int tmp ;

  {
  {
  tmp = isMethaneAlarm();
  }
  __VERIFIER_reached_control(735, __func__);
 if (tmp) { __VERIFIER_control_true(735, __func__);


  } else { __VERIFIER_control_false(737, __func__);

    {
    activatePump__wrappee__base();
    }
  }
  return;
}
}
void deactivatePump(void) 
{ 

  {
  pumpRunning = 0;
  return;
}
}
int isMethaneAlarm(void) 
{ int retValue_acc ;

  {
  {
  retValue_acc = isMethaneLevelCritical();
  }
  return (retValue_acc);
  return (retValue_acc);
}
}
int isPumpRunning(void) 
{ int retValue_acc ;

  {
  retValue_acc = pumpRunning;
  return (retValue_acc);
  return (retValue_acc);
}
}
void printPump(void) 
{ 

  {
  {
  printf("Pump(System:");
  }
  __VERIFIER_reached_control(780, __func__);
 if (systemActive) { __VERIFIER_control_true(780, __func__);

    {
    printf("On");
    }
  } else { __VERIFIER_control_false(784, __func__);

    {
    printf("Off");
    }
  }
  {
  printf(",Pump:");
  }
  __VERIFIER_reached_control(792, __func__);
 if (pumpRunning) { __VERIFIER_control_true(792, __func__);

    {
    printf("On");
    }
  } else { __VERIFIER_control_false(796, __func__);

    {
    printf("Off");
    }
  }
  {
  printf(") ");
  printEnvironment();
  printf("\n");
  }
  return;
}
}
void startSystem(void) 
{ 

  {
  systemActive = 1;
  return;
}
}
#pragma merger(0,"Specification1_spec.i","")
void __utac_acc__Specification1_spec__1(void) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  tmp = isMethaneLevelCritical();
  }
  __VERIFIER_reached_control(826, __func__);
 if (tmp) { __VERIFIER_control_true(826, __func__);

    {
    tmp___0 = isPumpRunning();
    }
    __VERIFIER_reached_control(830, __func__);
 if (tmp___0) { __VERIFIER_control_true(830, __func__);

      {
      __automaton_fail();
      }
    } else { __VERIFIER_control_false(834, __func__);


    }
  } else { __VERIFIER_control_false(837, __func__);


  }
  return;
}
}
#pragma merger(0,"featureselect.i","")
int select_one(void) ;
int select_one(void) 
{ int retValue_acc ;
  int choice = __VERIFIER_nondet_int();

  {
  retValue_acc = choice;
  return (retValue_acc);
  return (retValue_acc);
}
}
void select_features(void) 
{ 

  {
  return;
}
}
void select_helpers(void) 
{ 

  {
  return;
}
}
int valid_product(void) 
{ int retValue_acc ;

  {
  retValue_acc = 1;
  return (retValue_acc);
  return (retValue_acc);
}
}
